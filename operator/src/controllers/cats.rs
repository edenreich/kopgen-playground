// This file is generated by kopgen. Do not edit manually. If you need to make adjustments add it to .openapi-generator-ignore file.
use std::{sync::Arc, time::Duration};

use futures::stream::StreamExt;
use kube::{
    api::{PostParams, Resource},
    runtime::{controller::Action, watcher, Controller},
};
use log::{error, info, warn};
use openapi::{apis::cats_api::CatsApi, models::Cat as CatDto};

use crate::{
    errors::OperatorError,
    types::cat::{Cat, CatSpec, CatStatus},
    KubeApi,
};

/// TOOO - extract to config map maybe
const REQUEUE_AFTER_IN_SEC: u64 = 30;

/// - Holds shared clients for interacting with Kubernetes (kube_client).
/// - Holds shared clients for interacting with the external system.
pub struct ContextData {
    kube_client: Arc<dyn KubeApi<Cat> + Send + Sync>,
    cats_client: Arc<dyn CatsApi + Send + Sync>,
}

impl ContextData {
    fn new(
        kube_client: Arc<dyn KubeApi<Cat> + Send + Sync>,
        cats_client: Arc<dyn CatsApi + Send + Sync>,
    ) -> Self {
        Self {
            kube_client,
            cats_client,
        }
    }
}

/// Initializes and starts the controller to watch resources.
/// Flow:
///   - Creates a ContextData instance.
///   - Sets up the controller with the Kubernetes client.
///   - Defines the reconciliation logic (reconcile) and error handling (error_policy).
///   - Starts the event loop to process reconciliation results.
pub async fn handle(
    kube_client: Arc<dyn KubeApi<Cat> + Send + Sync>,
    cats_client: Arc<dyn CatsApi + Send + Sync>,
) -> Result<(), OperatorError> {
    info!("Starting the controller");
    let context = Arc::new(ContextData::new(kube_client.clone(), cats_client));
    let underlying_kube_api_client = kube_client.get_client();

    Controller::new(
        underlying_kube_api_client.clone(),
        watcher::Config::default(),
    )
    .owns(underlying_kube_api_client, watcher::Config::default())
    .run(reconcile, error_policy, context)
    .for_each(|res| async {
        match res {
            Ok(action) => info!("Reconciliation was successful, action: {:?}", action),
            Err(e) => error!("Error reconciling: {:?}", e),
        }
    })
    .await;

    info!("Cat Controller has stopped");
    Ok(())
}

/// Ensures the actual state of a resource matches the desired state.
/// Flow:
///   - Initialization: Clones necessary clients and extracts the uuid from the resource status.
///   - Status Setup: Adds default status if it's missing.
///   - Operation Handling:
///   - Deletion: If the resource is marked for deletion, invokes handle_delete.
///   - Creation: If there's no uuid, it's a new resource; invokes handle_create.
///   - Update: If the generation has changed, invokes handle_update.
///   - Drift Detection: Calls check_for_drift to synchronize any discrepancies between local and remote states.
///   - Requeue: Schedules the next reconciliation after a defined interval.
pub async fn reconcile(cat: Arc<Cat>, ctx: Arc<ContextData>) -> Result<Action, OperatorError> {
    let kube_client = ctx.kube_client.clone();
    let cats_client = ctx.cats_client.clone();
    let mut cat = cat.as_ref().clone();
    let uuid = cat
        .status
        .as_ref()
        .and_then(|status| status.uuid.clone())
        .unwrap_or_default();

    if cat.status.is_none() {
        add_default_status(&mut cat).await?;
    }

    if cat.meta().deletion_timestamp.is_some() {
        handle_delete(kube_client.as_ref(), cats_client.as_ref(), &mut cat, &uuid).await?;
    } else if uuid.is_empty() {
        handle_create(kube_client.as_ref(), cats_client.as_ref(), &mut cat).await?;
    } else if cat.meta().generation != cat.status.as_ref().as_ref().unwrap().observed_generation {
        handle_update(kube_client.as_ref(), cats_client.as_ref(), &mut cat, &uuid).await?;
    }

    check_for_drift(kube_client, cats_client, &mut cat).await?;
    Ok(Action::requeue(Duration::from_secs(REQUEUE_AFTER_IN_SEC)))
}

/// Initializes the status field of a Cat resource with default values.
pub async fn add_default_status(cat: &mut Cat) -> Result<(), OperatorError> {
    cat.status = Some(CatStatus {
        conditions: vec![],
        uuid: None,
        observed_generation: Some(0),
    });
    Ok(())
}

/// Ensures consistency between the local Kubernetes Cat resource
/// and its remote counterpart by detecting and resolving any discrepancies.
pub async fn check_for_drift(
    kube_client: Arc<dyn KubeApi<Cat>>,
    cats_client: Arc<dyn CatsApi>,
    cat: &mut Cat,
) -> Result<(), OperatorError> {
    let dto = converters::kube_type_to_dto(cat.clone());
    let uuid = converters::uuid_to_string(dto.uuid).unwrap_or_default();

    if uuid.is_empty() {
        warn!("Cat has no status, cannot get by id or check for drift. Skipping...");
        return Ok(());
    }

    match cats_client.get_cat_by_id(&uuid).await {
        Ok(dto) => {
            let remote_cat = converters::dto_to_kube_type(dto);
            if remote_cat != cat.spec {
                let current_cat_dto = converters::kube_type_to_dto(cat.clone());
                warn!("Cat has drifted remotely, sending an update to remote...");
                match cats_client.update_cat_by_id(&uuid, current_cat_dto).await {
                    Ok(_) => {
                        info!("Cat updated successfully");
                        let condition = kube_client.create_condition(
                            "Updated",
                            "AvailableUpdated",
                            "Updated the resource",
                            "Resource has been updated",
                            cat.meta().generation,
                        );
                        let mut cat_clone = cat.clone();
                        if let Some(status) = cat_clone.status.as_mut() {
                            status.conditions.push(condition);
                            status.observed_generation = cat.meta().generation;
                        }
                        kube_client.update_status(&cat_clone).await?
                    }
                    Err(e) => {
                        error!("Failed to update Cat: {:?}", e);
                        return Err(OperatorError::FailedToGetResource(e.into()));
                    }
                }
            }
        }
        Err(e) => {
            error!("Failed to get Cat: {:?}", e);
            return Err(OperatorError::FailedToGetResource(e.into()));
        }
    }

    Ok(())
}

/// Defines how the controller should respond to errors during reconciliation.
/// In this case, it logs the error and schedules a requeue for retry.
fn error_policy(_resource: Arc<Cat>, error: &OperatorError, _ctx: Arc<ContextData>) -> Action {
    error!("Error processing event: {:?}", error);
    Action::requeue(Duration::from_secs(REQUEUE_AFTER_IN_SEC))
}

/// Deletes the remote resource and removes the finalizer from the local Kubernetes resource.
pub async fn handle_delete(
    kube_client: &dyn KubeApi<Cat>,
    cats_client: &dyn CatsApi,
    cat: &mut Cat,
    uuid: &str,
) -> Result<(), OperatorError> {
    if uuid.is_empty() {
        warn!("Cat has no status, cannot delete by id. Skipping...");
        return Ok(());
    }

    cats_client.delete_cat_by_id(uuid).await.map_err(|e| {
        error!("Failed to delete cat: {:?}", e);
        OperatorError::FailedToDeleteResource(e.into())
    })?;

    kube_client.remove_finalizer(cat).await?;
    info!("Successfully deleted cat");
    Ok(())
}

/// Updates the remote resource and synchronizes the local Kubernetes resource.
pub async fn handle_update(
    kube_client: &dyn KubeApi<Cat>,
    cats_client: &dyn CatsApi,
    cat: &mut Cat,
    uuid: &str,
) -> Result<(), OperatorError> {
    if uuid.is_empty() {
        return Err(OperatorError::InvalidResource("uuid is empty".to_string()));
    }

    let dto = converters::kube_type_to_dto(cat.clone());

    cats_client
        .update_cat_by_id(uuid, dto)
        .await
        .map_err(|e| OperatorError::FailedToUpdateResource(e.into()))?;

    let cat_name = cat.metadata.name.as_deref().unwrap_or_default();
    kube_client
        .get_client()
        .replace(cat_name, &PostParams::default(), cat)
        .await
        .map_err(|e| OperatorError::FailedToUpdateResource(e.into()))?;

    info!("Updated a cat by id went successfully");
    Ok(())
}

/// Creates a corresponding remote resource and
/// updates the local Kubernetes resource with necessary metadata.
pub async fn handle_create(
    kube_client: &dyn KubeApi<Cat>,
    cats_client: &dyn CatsApi,
    cat: &mut Cat,
) -> Result<(), OperatorError> {
    if cat.status.is_none() {
        add_default_status(cat).await?;
    }

    let dto = converters::kube_type_to_dto(cat.clone());

    match cats_client.create_cat(dto.clone()).await {
        Ok(remote_cat) => {
            if let Some(uuid) = remote_cat.uuid {
                let uuid = converters::uuid_to_string(Some(uuid)).unwrap();
                kube_client.add_finalizer(cat).await?;
                let generation = cat.meta().generation;
                let condition = kube_client.create_condition(
                    "Created",
                    "AvailableCreated",
                    "Created the resource",
                    "Resource has been created",
                    generation,
                );
                if let Some(status) = cat.status.as_mut() {
                    if !status
                        .conditions
                        .iter()
                        .any(|c| c.type_ == "AvailableCreated")
                    {
                        status.conditions.push(condition);
                    }
                    status.uuid = Some(uuid);
                    status.observed_generation = generation;
                }
                kube_client
                    .update_status(&cat)
                    .await
                    .map_err(|e| OperatorError::FailedToUpdateStatus(e.into()))
            } else {
                warn!("Remote cat has no uuid, cannot update status");
                Ok(())
            }
        }
        Err(e) => {
            error!("Failed to create a new cat: {:?}", e);
            Err(OperatorError::FailedToCreateResource(e.into()))
        }
    }
}

/// Provides utility functions to convert between Kubernetes types
/// and Data Transfer Objects.
/// This is essential for synchronizing state between Kubernetes and external systems.
pub mod converters {
    use super::{Cat, CatDto, CatSpec};

    pub fn uuid_to_string(uuid: Option<uuid::Uuid>) -> Option<String> {
        uuid.map(|uuid| uuid.to_string())
    }

    fn string_to_uuid(uuid: Option<String>) -> Option<uuid::Uuid> {
        match uuid {
            Some(uuid) => match uuid::Uuid::parse_str(&uuid) {
                Ok(uuid) => Some(uuid),
                Err(_) => None,
            },
            None => None,
        }
    }

    pub fn kube_type_to_dto(cat: Cat) -> CatDto {
        let uuid = match cat.status {
            Some(status) => string_to_uuid(status.uuid),
            None => None,
        };
        CatDto {
            uuid,
            name: cat.spec.name,
            breed: cat.spec.breed,
            age: cat.spec.age,
        }
    }

    pub fn dto_to_kube_type(cat: CatDto) -> CatSpec {
        CatSpec {
            name: cat.name,
            breed: cat.breed,
            age: cat.age,
        }
    }
}
