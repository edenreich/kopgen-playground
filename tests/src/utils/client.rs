/// This file is generated by kopgen. Do not edit manually. If you need to make adjustments add it to .openapi-generator-ignore file.
use anyhow::Result;
use async_trait::async_trait;
use jsonpath_lib as jsonpath;
use k8s_openapi::apiextensions_apiserver::pkg::apis::apiextensions::v1::CustomResourceDefinition;
use kube::{
    core::{object::HasStatus, NamespaceResourceScope},
    Api, Client, Resource,
};
use log::{info, warn};
use serde::{de::DeserializeOwned, Serialize};
use std::{fmt::Debug, time::Duration};
use tokio::time::sleep;

/// Sets up a Kubernetes API client for managing `CustomResourceDefinition` resources.
///
/// # Returns
///
/// A `Result` containing the `Api<CustomResourceDefinition>` on success or an error on failure.
pub async fn setup_crd() -> Result<Api<CustomResourceDefinition>> {
    let client = Client::try_default().await?;
    let api: Api<CustomResourceDefinition> = Api::all(client);
    Ok(api)
}

/// Sets up a Kubernetes API client for managing resources of type `T`.
/// The client is namespaced to the `default` namespace.
/// The resource must implement the `Resource`, `Clone`, `DeserializeOwned`, `Serialize`, `Debug`, and `HasStatus` traits.
/// The resource's `DynamicType` must implement the `Default` trait.
/// The resource must have a `NamespaceResourceScope`.
/// The resource must have a `Status` field.
pub async fn setup<T>() -> Result<Api<T>>
where
    T: Resource + Clone + DeserializeOwned + Serialize + Debug + HasStatus,
    <T as Resource>::DynamicType: Default,
    T: Resource<Scope = NamespaceResourceScope>,
{
    let client = Client::try_default().await?;
    let api: Api<T> = Api::namespaced(client, "default");
    Ok(api)
}

#[async_trait]
pub trait Waiter {
    /// Asynchronously waits for a specific field in the resource to be present.
    ///
    /// This function periodically polls the Kubernetes API to check if a particular field,
    /// specified by a JSON path, exists within the resource. It continues to
    /// poll until the field is found or the specified timeout duration is reached.
    ///
    /// # Arguments
    ///
    /// * `api` - A reference to the Kubernetes API client for the resource.
    /// * `name` - The name of the resource to monitor.
    /// * `json_path` - The JSON path expression pointing to the desired field.
    /// * `timeout` - The maximum duration to wait for the field to appear.
    ///
    /// # Returns
    ///
    /// * `Ok(())` if the field is found within the timeout period.
    /// * `Err(anyhow::Error)` if the timeout is reached without finding the field.
    ///
    /// # Example
    ///
    /// ```rust
    /// use kube::Api;
    /// use std::time::Duration;
    /// use your_crate::{Cat, client};
    ///
    /// #[tokio::main]
    /// async fn main() -> anyhow::Result<()> {
    ///     let api: Api<Cat> = client::setup::<Cat>().await?;
    ///     api.wait_for_field("test-cat", "$.metadata.finalizers", Duration::from_secs(30)).await?;
    ///     let cat = api.get("test-cat").await?;
    ///     assert_eq!(cat.metadata.finalizers, Some(vec!["test-finalizer".to_string()]));
    ///     Ok(())
    /// }
    /// ```
    async fn wait_for_field(&self, name: &str, json_path: &str, timeout: Duration) -> Result<()>;
}

#[async_trait]
impl<T> Waiter for Api<T>
where
    T: Resource + Clone + DeserializeOwned + Serialize + Debug + HasStatus + Send + Sync + 'static,
{
    /// Asynchronously waits for a specific field in the resource's metadata to be present.
    ///
    /// This function periodically polls the Kubernetes API to check if a particular field,
    /// specified by a JSON path, exists within the resource's metadata. It continues to
    /// poll until the field is found or the specified timeout duration is reached.
    ///
    /// # Arguments
    ///
    /// * `api` - A reference to the Kubernetes API client for the resource.
    /// * `name` - The name of the resource to monitor.
    /// * `json_path` - The JSON path expression pointing to the desired field.
    /// * `timeout` - The maximum duration to wait for the field to appear.
    ///
    /// # Returns
    ///
    /// * `Ok(())` if the field is found within the timeout period.
    /// * `Err(anyhow::Error)` if the timeout is reached without finding the field.
    ///
    /// # Example
    ///
    /// ```rust
    /// use kube::Api;
    /// use std::time::Duration;
    /// use your_crate::{Cat, client};
    ///
    /// #[tokio::main]
    /// async fn main() -> anyhow::Result<()> {
    ///     let api: Api<Cat> = client::setup::<Cat>().await?;
    ///     api.wait_for_field("test-cat", "$.metadata.finalizers", Duration::from_secs(30)).await?;
    ///     let cat = api.get("test-cat").await?;
    ///     assert_eq!(cat.metadata.finalizers, Some(vec!["test-finalizer".to_string()]));
    ///     Ok(())
    /// }
    /// ```
    async fn wait_for_field(&self, name: &str, json_path: &str, timeout: Duration) -> Result<()> {
        let start = std::time::Instant::now();

        while start.elapsed() < timeout {
            let resource = match self.get(name).await {
                Ok(res) => res,
                Err(e) => {
                    warn!("Failed to get resource '{}': {}", name, e);
                    sleep(Duration::from_secs(1)).await;
                    continue;
                }
            };
            let resource_json = serde_json::to_value(&resource)?;

            match jsonpath::select(&resource_json, json_path) {
                Ok(values) => {
                    if !values.is_empty() {
                        info!("Field '{}' found in resource '{}'.", json_path, name);
                        return Ok(());
                    }
                }
                Err(e) => {
                    warn!("Invalid JSONPath '{}': {}", json_path, e);
                }
            }

            sleep(Duration::from_secs(1)).await;
        }

        Err(anyhow::anyhow!(
            "Timeout waiting for field '{}' in resource '{}'",
            json_path,
            name
        ))
    }
}
